## 命令行参数解析代码设计

### 问题分析

当前 `KernelThread` 函数中的参数解析逻辑存在错误：

1. 错误地将第一个空格前的字符数作为 argc
2. 使用了未定义的变量 `argv`
3. 缺少正确的字符串分割逻辑

### 解决方案

设计一个完整的命令行参数解析函数，实现：

1. 将输入字符串按空格分割为多个参数
2. 正确计算参数数量 `argc`
3. 为每个参数分配内存并复制内容
4. 生成符合标准的 `argv` 数组
5. 支持基本的引号处理（可选）

### 实现步骤

1. 在 `thread.cc` 中添加一个 `ParseArgs` 辅助函数
2. 修复 `KernelThread` 函数，使用新的解析函数
3. 确保内存正确分配和释放

### 代码设计

```cpp
// 辅助函数：解析命令行参数字符串
void ParseArgs(char *arg, std::uint64_t &argc, char **&argv) {
    argc = 0;
    argv = nullptr;
    
    if (arg == nullptr || *arg == '\0') {
        return;
    }
    
    // 第一次遍历：计算参数数量
    char *ptr = arg;
    bool in_arg = false;
    
    while (*ptr != '\0') {
        if (*ptr == ' ') {
            in_arg = false;
        } else if (!in_arg) {
            in_arg = true;
            argc++;
        }
        ptr++;
    }
    
    if (argc == 0) {
        return;
    }
    
    // 分配argv数组
    argv = reinterpret_cast<char **>(mm::page::Alloc((argc + 1) * sizeof(char *)));
    if (argv == nullptr) {
        argc = 0;
        return;
    }
    
    // 第二次遍历：复制每个参数字符串
    ptr = arg;
    std::uint64_t arg_index = 0;
    in_arg = false;
    char *arg_start = nullptr;
    
    while (*ptr != '\0' && arg_index < argc) {
        if (*ptr == ' ') {
            if (in_arg) {
                // 结束当前参数
                size_t len = ptr - arg_start;
                argv[arg_index] = reinterpret_cast<char *>(mm::page::Alloc(len + 1));
                if (argv[arg_index] != nullptr) {
                    std::memcpy(argv[arg_index], arg_start, len);
                    argv[arg_index][len] = '\0';
                    arg_index++;
                }
                in_arg = false;
            }
        } else if (!in_arg) {
            // 开始新参数
            arg_start = ptr;
            in_arg = true;
        }
        ptr++;
    }
    
    // 处理最后一个参数
    if (in_arg && arg_index < argc) {
        size_t len = ptr - arg_start;
        argv[arg_index] = reinterpret_cast<char *>(mm::page::Alloc(len + 1));
        if (argv[arg_index] != nullptr) {
            std::memcpy(argv[arg_index], arg_start, len);
            argv[arg_index][len] = '\0';
            arg_index++;
        }
    }
    
    // 确保argv以nullptr结尾
    argv[arg_index] = nullptr;
    // 更新实际argc
    argc = arg_index;
}
```

然后修改 `KernelThread` 函数，使用这个新的解析函数来替代当前的错误逻辑。
