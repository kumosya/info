#ifndef LIBCPP_MEMORY_H
#define LIBCPP_MEMORY_H

#include <stddef.h>
#include <stdlib.h>
#include <utility>

namespace std {

template <class T>
struct allocator {
    typedef T value_type;
    allocator() noexcept {}
    T* allocate(size_t n) { return (T*)malloc(n * sizeof(T)); }
    void deallocate(T* p, size_t) { free(p); }
};

template <class T>
class unique_ptr {
    T* p_;
public:
    explicit unique_ptr(T* p = nullptr) noexcept : p_(p) {}
    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;
    unique_ptr(unique_ptr&& o) noexcept : p_(o.p_) { o.p_ = nullptr; }
    unique_ptr& operator=(unique_ptr&& o) noexcept { if (this != &o) { reset(o.release()); } return *this; }
    ~unique_ptr() { if (p_) delete p_; }
    T* get() const noexcept { return p_; }
    T* release() noexcept { T* t = p_; p_ = nullptr; return t; }
    void reset(T* q = nullptr) noexcept { if (p_) delete p_; p_ = q; }
    T& operator*() const { return *p_; }
    T* operator->() const { return p_; }
};

} // namespace std

#endif // LIBCPP_MEMORY_H
