#ifndef LIBCPP_VECTOR_H
#define LIBCPP_VECTOR_H

#include <stddef.h>
#include <utility>
#include <memory>
#include <new>
#include <stdlib.h>

namespace std {

template <class T>
class vector {
    T* data_;
    size_t size_;
    size_t cap_;
public:
    typedef T value_type;
    typedef T* iterator;

    vector() noexcept : data_(nullptr), size_(0), cap_(0) {}
    explicit vector(size_t n) : size_(n), cap_(n) { data_ = (T*)malloc(n * sizeof(T)); for (size_t i=0;i<n;i++) new(&data_[i]) T(); }
    ~vector() { clear(); free(data_); }

    void reserve(size_t n) {
        if (n <= cap_) return;
        T* nd = (T*)malloc(n * sizeof(T));
        for (size_t i = 0; i < size_; ++i) new(&nd[i]) T(std::move(data_[i]));
        for (size_t i = 0; i < size_; ++i) data_[i].~T();
        free(data_);
        data_ = nd;
        cap_ = n;
    }

    void push_back(const T& v) {
        if (size_ == cap_) reserve(cap_ ? cap_ * 2 : 4);
        new(&data_[size_]) T(v);
        ++size_;
    }

    void push_back(T&& v) {
        if (size_ == cap_) reserve(cap_ ? cap_ * 2 : 4);
        new(&data_[size_]) T(std::move(v));
        ++size_;
    }

    size_t size() const noexcept { return size_; }
    size_t capacity() const noexcept { return cap_; }
    bool empty() const noexcept { return size_ == 0; }
    T& operator[](size_t i) { return data_[i]; }
    const T& operator[](size_t i) const { return data_[i]; }
    iterator begin() noexcept { return data_; }
    iterator end() noexcept { return data_ + size_; }

    void clear() noexcept { for (size_t i=0;i<size_;++i) data_[i].~T(); size_ = 0; }
};

} // namespace std

#endif // LIBCPP_VECTOR_H
