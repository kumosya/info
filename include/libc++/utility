#ifndef LIBCPP_UTILITY_H
#define LIBCPP_UTILITY_H

#include <type_traits>

namespace std {

template <class T> constexpr typename remove_reference<T>::type&& move(T&& t) noexcept {
    return static_cast<typename remove_reference<T>::type&&>(t);
}

template <class T> constexpr T&& forward(typename remove_reference<T>::type& t) noexcept {
    return static_cast<T&&>(t);
}

template <class T> constexpr T&& forward(typename remove_reference<T>::type&& t) noexcept {
    return static_cast<T&&>(t);
}

template <class T>
struct pair {
    typedef T first_type; // minimal: single-value pair for convenience
    T first;
    T second;
    constexpr pair() : first(), second() {}
    constexpr pair(const T& a, const T& b) : first(a), second(b) {}
};

template <class T>
constexpr void swap(T& a, T& b) {
    T tmp = move(a);
    a = move(b);
    b = move(tmp);
}

} // namespace std

#endif // LIBCPP_UTILITY_H
